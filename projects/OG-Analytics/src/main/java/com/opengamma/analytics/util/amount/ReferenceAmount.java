/**
 * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.analytics.util.amount;

import java.util.HashMap;
import java.util.Map.Entry;

import org.joda.beans.Bean;
import org.joda.beans.BeanDefinition;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBean;

import com.opengamma.util.ArgumentChecker;
import java.util.Map;
import org.joda.beans.BeanBuilder;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaBean;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;
import org.joda.beans.Property;
import org.joda.beans.impl.direct.DirectMetaProperty;

/**
 * Object to represent values linked to a reference for which the values can be added or multiplied by a constant.
 * Used for different sensitivities (parallel curve sensitivity,...). The objects stored as a HashMap(T, Double).
 * @param <T> The reference object.
 */
@BeanDefinition
public class ReferenceAmount<T> extends DirectBean {

  /**
   * The data stored as a map. Not null.
   */
  @PropertyDefinition(validate = "notNull")
  private final Map<T, Double> _data;

  /**
   * Constructor. Create an empty map.
   */
  public ReferenceAmount() {
    _data = new HashMap<>();
  }

  /**
   * Constructor from an existing map. The map is used in the new object (no new map is created).
   * @param map The map.
   */
  private ReferenceAmount(final Map<T, Double> map) {
    _data = map;
  }

  /**
   * Gets the underlying map.
   * @return The map.
   */
  public Map<T, Double> getMap() {
    return _data;
  }

  /**
   * Add a value to the object. The existing object is modified. If the point is not in the existing points of the object, it is put in the map.
   * If a point is already in the existing points of the object, the value is added to the existing value.
   * @param point The surface point.
   * @param value The associated value.
   */
  public void add(final T point, final Double value) {
    ArgumentChecker.notNull(point, "Point");
    if (_data.containsKey(point)) {
      _data.put(point, value + _data.get(point));
    } else {
      _data.put(point, value);
    }
  }

  /**
   * Create a new object containing the points of the initial object plus the points of another object. If two points <T> are identical, the values are added.
   * @param other The other ReferenceAmount.
   * @return The total.
   */
  public ReferenceAmount<T> plus(final ReferenceAmount<T> other) {
    final HashMap<T, Double> plusMap = new HashMap<>(_data);
    final ReferenceAmount<T> plus = new ReferenceAmount<>(plusMap);
    for (final Entry<T, Double> p : other._data.entrySet()) {
      plus.add(p.getKey(), p.getValue());
    }
    return plus;
  }

  /**
   * Create a new object containing the point of the initial object with the all values multiplied by a given factor.
   * @param factor The multiplicative factor.
   * @return The multiplied surface.
   */
  public ReferenceAmount<T> multiplyBy(final double factor) {
    final HashMap<T, Double> multiplied = new HashMap<>();
    for (final T p : _data.keySet()) {
      multiplied.put(p, _data.get(p) * factor);
    }
    return new ReferenceAmount<>(multiplied);
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + _data.hashCode();
    return result;
  }

  @Override
  public boolean equals(final Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    @SuppressWarnings("unchecked")
    final ReferenceAmount<T> other = (ReferenceAmount<T>) obj;
    if (_data == null) {
      if (other._data != null) {
        return false;
      }
    } else if (!_data.equals(other._data)) {
      return false;
    }
    return true;
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code ReferenceAmount}.
   * @return the meta-bean, not null
   */
  @SuppressWarnings("rawtypes")
  public static ReferenceAmount.Meta meta() {
    return ReferenceAmount.Meta.INSTANCE;
  }

  /**
   * The meta-bean for {@code ReferenceAmount}.
   * @param <R>  the bean's generic type
   * @param cls  the bean's generic type
   * @return the meta-bean, not null
   */
  @SuppressWarnings("unchecked")
  public static <R> ReferenceAmount.Meta<R> metaReferenceAmount(Class<R> cls) {
    return ReferenceAmount.Meta.INSTANCE;
  }

  static {
    JodaBeanUtils.registerMetaBean(ReferenceAmount.Meta.INSTANCE);
  }

  @SuppressWarnings("unchecked")
  @Override
  public ReferenceAmount.Meta<T> metaBean() {
    return ReferenceAmount.Meta.INSTANCE;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the data stored as a map. Not null.
   * @return the value of the property, not null
   */
  public Map<T, Double> getData() {
    return _data;
  }

  /**
   * Sets the data stored as a map. Not null.
   * @param data  the new value of the property, not null
   */
  public void setData(Map<T, Double> data) {
    JodaBeanUtils.notNull(data, "data");
    this._data.clear();
    this._data.putAll(data);
  }

  /**
   * Gets the the {@code data} property.
   * @return the property, not null
   */
  public final Property<Map<T, Double>> data() {
    return metaBean().data().createProperty(this);
  }

  //-----------------------------------------------------------------------
  @Override
  public ReferenceAmount<T> clone() {
    return JodaBeanUtils.cloneAlways(this);
  }

  @Override
  public String toString() {
    StringBuilder buf = new StringBuilder(64);
    buf.append("ReferenceAmount{");
    int len = buf.length();
    toString(buf);
    if (buf.length() > len) {
      buf.setLength(buf.length() - 2);
    }
    buf.append('}');
    return buf.toString();
  }

  protected void toString(StringBuilder buf) {
    buf.append("data").append('=').append(JodaBeanUtils.toString(getData())).append(',').append(' ');
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code ReferenceAmount}.
   * @param <T>  the type
   */
  public static class Meta<T> extends DirectMetaBean {
    /**
     * The singleton instance of the meta-bean.
     */
    @SuppressWarnings("rawtypes")
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code data} property.
     */
    @SuppressWarnings({"unchecked", "rawtypes" })
    private final MetaProperty<Map<T, Double>> _data = DirectMetaProperty.ofReadWrite(
        this, "data", ReferenceAmount.class, (Class) Map.class);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, null,
        "data");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case 3076010:  // data
          return _data;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends ReferenceAmount<T>> builder() {
      return new DirectBeanBuilder<ReferenceAmount<T>>(new ReferenceAmount<T>());
    }

    @SuppressWarnings({"unchecked", "rawtypes" })
    @Override
    public Class<? extends ReferenceAmount<T>> beanType() {
      return (Class) ReferenceAmount.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    /**
     * The meta-property for the {@code data} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<Map<T, Double>> data() {
      return _data;
    }

    //-----------------------------------------------------------------------
    @Override
    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
      switch (propertyName.hashCode()) {
        case 3076010:  // data
          return ((ReferenceAmount<?>) bean).getData();
      }
      return super.propertyGet(bean, propertyName, quiet);
    }

    @SuppressWarnings("unchecked")
    @Override
    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
      switch (propertyName.hashCode()) {
        case 3076010:  // data
          ((ReferenceAmount<T>) bean).setData((Map<T, Double>) newValue);
          return;
      }
      super.propertySet(bean, propertyName, newValue, quiet);
    }

    @Override
    protected void validate(Bean bean) {
      JodaBeanUtils.notNull(((ReferenceAmount<?>) bean)._data, "data");
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}
